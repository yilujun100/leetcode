/**
 * 70. 爬楼梯
 */

// 当碰到一个问题，懵逼的时候：
// 1.能不能暴力破解
// 2.基本情况
// 找最近重复子问题，为什么要找最近重复子问题？因为我们写程序只能写if else或者是for while这样的loop,
// 然后就是程序不断调自己和递归，除了前面if else这种巨简单的问题之外，其他的情况下其实就是for while和
// recursion都是不断的重复。为什么会这样，究其原因，计算机是人类发明的，那么人类能发明出来的工具肯定没有
// 人脑这么强大，它其实就是一个简单的重复式的机器。再加上我们现在用的这些程序和用的这些算法，都是最简单的算法，
// 所以不涉及任何关于人工智能的东西，你就把它想成一个不断重复在那里干事情的东西就好了。
// 你要让它用重复的东西来解决你这种问题的话说明这个问题本身就是可重复的。
// 1: 1
// 2: 2
// 3: f(1) + f(2) 如果要上第三级台阶，你必须从第二级台阶上面跨一步跨到第三级台阶来，这是第一种走法
// 第二种走法就是你从第一级台阶一下跨两步跨到第三级台阶来，你只能从n-1级台阶或者从n-2级台阶走过来，
// 那么你会发现，第3级台阶的走法就等于之前第一级台阶的走法再加上第二级台阶的走法即可
// n: f(n-1) + f(n-2)
// 这道题本质就是求斐波那契数列(不要使用递归，时间复杂度过高且会存在很多冗余的重复计算)

export default n => {
	let a = [0, 1, 2];
	for (let i = 3; i <= n; i++) {
		a[i] = a[i - 1] + a[i - 2];
	}
	return a[n];
};
